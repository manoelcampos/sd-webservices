:source-highlighter: highlightjs
:imagesdir: images
:numbered:
:unsafe:
:icons: font
:allow-uri-read:

ifdef::env-github[]
:outfilesuffix: .adoc
:caution-caption: :fire:
:important-caption: :exclamation:
:note-caption: :paperclip:
:tip-caption: :bulb:
:warning-caption: :warning:
endif::[]

ifdef::env-github[]
IMPORTANT: ACESSE O TUTORIAL ONLINE http://manoelcampos.com/sd-webservices/4.4-ws-rest-cadastro/[NESTE LINK]. **O ACESSO DIRETAMENTE PELO GITHUB N√ÉO PERMITE A EXIBI√á√ÉO DE V√çDEOS.**
endif::[]

= Desenvolvimento Web Services REST em Java utilizando JAX-RS com JPA e CDI no NetBeans (link:https://kinolien.github.io/gitzip/?download=/manoelcampos/sd-webservices/tree/master/4.4-ws-rest-cadastro[zip])
por Manoel Campos da Silva Filho

REST se tornou o padr√£o de fato para o desenvolvimento de Web Services (WS's) h√° alguns anos, em oposi√ß√£o ao protocolo SOAP padronizado pela W3C.
Isto se deve a diversos fatores como:

- Troca de mensagens simplificadas entre cliente e servidor, normalmente utilizando JSON no lugar de XML. Isto faz com o tr√°fego de dados e o delay causado pela troca de mensagens sejam reduzidos. Tais caracter√≠sticas s√£o fundamentais para dispositivos m√≥veis que normalmente possuem pacotes de dados com tr√°fego e velocidade limitados.
- Utiliza√ß√£o apenas dos recursos do protocolo HTTP para troca de mensagens, sem precisar empacotar os dados da requisi√ß√£o no cabe√ßalho de outro protocolo como o SOAP, que apenas aumenta o tamanho dos pacotes de dados sendo enviados.
- Utiliza√ß√£o de URLs convencionalmente amig√°veis, tornando muito simples o teste de clientes REST utilizando ferramentas de linha de comando como curl ou outras como plugins para navegadores.
- Ampla ado√ß√£o pelo mercado, tornando-o um padr√£o de fato, amplamente suportado pela comunidade de software livre com a disponibiliza√ß√£o de in√∫meras bibliotecas e suporte nos mais conhecidos IDEs do mercado.
- Grandes empresas como Google, Facebook, Twitter, Yahoo e muitas outras fornecem incont√°veis servi√ßos REST para as mais variadas finalidades. Tais WS's fornecem desde integra√ß√£o com servi√ßos como Google Maps, YouTube e Google Translator, informa√ß√µes sobre previs√£o do tempo e cota√ß√£o de moedas (inclusive de criptomoedas como Bitcoin), etc.

Por estes motivos, SOAP se tornou absoleto, dando lugar ao REST. Desta forma, neste tutorial ser√° mostrado o desenvolvimento de uma aplica√ß√£o servidora e outra cliente utilizando o padr√£o REST. Ser√° mostrado um passo-a-passo para criar as aplica√ß√µes do zero, explicando as tecnologias utilizadas e configura√ß√µes necess√°rias. Ent√£o vamos l√°.

== Ferramentas Necess√°rias

Para este projeto vamos utilizar as seguintes ferramentas:

. JDK 1.8 (a maioria dos servidores de aplica√ß√£o ainda n√£o suporta vers√µes mais recentes do JDK)
. http://netbeans.apache.org[IDE NetBeans 11]
. Servidor de aplica√ß√£o GlassFish 5 (a ser mostrado como instalar)

Considera-se que voc√™ j√° tem os itens 1 e 2 previamente instalados.

=== MySQL Server

Nossa aplica√ß√£o servidora utilizar√° um banco de dados MySQL, apesar que qualquer outro banco pode ser utilizado. Se estiver utilizando Linux, como Ubuntu, basta fazer o download do MySQL Server via apt-get com o comando abaixo:

[source,bash]
----
sudo apt-get install mysql-server
----

Se estiver usando Windows ou macOS, pode baixar o instalador do
MySQL Server Community https://dev.mysql.com/downloads/mysql/[aqui].
Certifique-se de conferir qual a vers√£o do MySQL est√° sendo baixada,
pois existem diferen√ßas de configura√ß√£o para as vers√µes 5 e 8 que ser√£o discutidas adiante.
No Linux, basta digitar `mysql --version` no terminal depois de instalar o servidor para verificar a vers√£o.

==== Criando o Banco de Dados

Utilize o NetBeans para criar o banco de dados chamado `cadastro-rest` para o nosso sistema, acessando a aba "Services".

ifdef::env-github[]
O processo √© mostrado neste https://youtu.be/g0R11_1Fv1I[v√≠deo].
endif::[]

ifndef::env-github[]
O processo √© mostrado no v√≠deo a seguir.

video::g0R11_1Fv1I[youtube, 800, 600]
endif::[]

IMPORTANT: N√£o precisaremos criar as tabelas manualmente, como veremos a seguir.

=== GlassFish 5

Vamos utilizar o GlassFish 5 por ser a √∫ltima vers√£o at√© o momento de elabora√ß√£o deste tutorial. 

ifdef::env-github[]
Este https://youtu.be/_Af4RK9UvRw[v√≠deo] mostra os passos para instalar o GlassFish 5 .
endif::[]

ifndef::env-github[]
O v√≠deo a seguir mostra os passos para instalar o GlassFish 5.

video::_Af4RK9UvRw[youtube, 800, 600]
endif::[]

Como vamos usar o MySQL como banco de dados, precisaremos do MySQL Connector J, driver JBDC do MySQL (que vai ser utilizado internamente para acesso ao BD). Baixe o driver no https://dev.mysql.com/downloads/connector/j/[site oficial].

Ap√≥s descompactar o driver, o √∫nico arquivo que nos interessa √© o `mysql-connector-java-X.X.X-bin.jar` (onde X.X.X √© a vers√£o do driver). Copie tal arquivo para a pasta `glassfish5/glassfish/domains/domain1/lib` (considerando que `glassfish5` √© a pasta onde descompactou o GlassFish). As bibliotecas colocadas em tal pasta ser√£o carregadas automaticamente pelo GlassFish.

== Estrutura do projeto

Utilizaremos o https://pt.wikipedia.org/wiki/Hibernate[Hibernate] como framework de https://pt.wikipedia.org/wiki/Mapeamento_objeto-relacional[mapeamento objeto relacional (Object Relational Mapping - ORM)], que √© uma implementa√ß√£o da especifica√ß√£o https://pt.wikipedia.org/wiki/Java_Persistence_API[JPA]. Ele nos permite "esquecer" os detalhes de BDs relacionais (como SQL, Primary Keys (PKs), Foreign Keys (FKs), cria√ß√£o de tabelas, etc) e assim podermos trabalhar exclusivamente em um modelo orientado a objetos, mesmo para manipula√ß√£o dos dados no banco.

A especifica√ß√£o http://cdi-spec.org[Context and Dependency Injection (CDI)] permite que objetos sejam injetados (ou seja, criados automaticamente) onde precisarmos. Tal especifica√ß√£o √© implementada por padr√£o em servidores de aplica√ß√£o como o GlassFish ou WildFly. 

== O projeto

O projeto que desenvolveremos ser√° bem simples. O diagrama de classe abaixo mostra que teremos apenas duas classes de neg√≥cio `Usuario` e `Cidade`. O servidor disponibilizar√° um cadastro de usu√°rios por meio de um Web Service REST. A classe `Usuario` tem apenas dados b√°sicos e mais um atributo que indica a cidade onde ele mora. 

Existe uma interface `Cadastro` que ser√° implementada por todas as classes que representarem tabelas no BD. Tal interface apenas define  um getter e setter para um atributo `id` que cada classe de neg√≥cio ter√°. Assim, estamos definindo que todas essas classes devem ter um atributo `id`, que ser√° bastante √∫til posteriormente.

image::class-diagram.jpg[title=Diagrama das Classes de Neg√≥cio]

== Iniciando o Desenvolvimento

Vamos criar um projeto Maven de uma Web Application no NetBeans, como mostra a anima√ß√£o abaixo.

image::create-project.gif[]

O campo `groupId` na pen√∫ltima tela de cria√ß√£o do projeto foi preenchido com `com.manoelcampos` indicando um nome de dom√≠nio invertido para identificar a empresa ou pessoa que desenvolveu o projeto. Caso voc√™ tenha um dom√≠nio, pode utilizar. Caso n√£o tenho, pode inventar um ou usar qualquer nome que desejar. O campo `package` √© automaticamente formado pela jun√ß√£o do `groupId` com o nome dado para o projeto no primeiro campo.

Se nunca utilizou Maven antes, esta √© uma ferramenta para gerenciamento de depend√™ncias no seu projeto, permitindo baixar as depend√™ncias indicadas automaticamente. N√£o confunda com o CDI que usaremos para inje√ß√£o de depend√™ncias. No Maven dizemos quais bibliotecas nosso projeto precisa. Usando CDI, dizemos quais objetos devem ser injetados (automaticamente instanciados) quando precisarmos deles.

=== Criando as classes de neg√≥cio

Agora vamos criar as classes `Usuario` e `Cidade`. Primeiro vamos criar a classe `Usuario` dentro de um subpacote chamado `model`, onde colocaremos todas as classes de neg√≥cio (que representam o modelo do neg√≥cio).

image::create-business-class.gif[]

Veja que apenas adicionamos `.model` ao final do nome do pacote ao criar a classe. Agora crie a classe `Cidade` dentro deste pacote `model`. 

Como tais classes representar√£o tabelas no BD, cada uma delas deve ter um atributo `id` (neste caso, este id representa uma chave prim√°ria simples). Para isso, vamos criar uma interface chamada `Cadastro` que define m√©todos getter e setter para este atributo de tais classes. Tal interface ficar√° no mesmo pacote das classes e ter√° o seguinte c√≥digo:

[source, java]
----
public interface Cadastro {
    long getId();
    void setId(long id);
}
----

Vamos ent√£o indicar que nossas classes `Usuario` e `Cidade` implementam tal interface.

image::implement-interface-methods.gif[]

Como estas classes agora precisam implementar os m√©todos na interface, podemos usar o NetBeans para incluir o corpo dos m√©todos pra n√≥s, como mostrado acima. Fa√ßa o mesmo para as duas classes de neg√≥cio.

Nossa classe `Usuario` ter√° apenas os atributos abaixo, com os respectivos getters e setters. 

[source, java]
----
    private long id;
    private String nome;
    private String cpf;

    @ManyToOne
    private Cidade cidade;
----

Observe que na classe `Usuario` temos um atributo do tipo `Cidade`. Isto representa um relacionamento entre as duas classes. Neste caso, a cardinalidade da associa√ß√£o entre `Usuario` e `Cidade` (nesta dire√ß√£o) √© n..1, ou seja, muitos usu√°rios s√£o de uma mesma cidade. Para representar tal associa√ß√£o precisamos usar a anota√ß√£o `@ManyToOne` no atributo. Desta forma, no banco de dados ser√° criada uma chave estrangeira dentro da tabela `Usuario` para armazenar o id da `Cidade`. 

Podemos usar o NetBeans para criar tais m√©todos para gente. Temos apenas que apagar o c√≥digo gerado para os m√©todos `getId()` e `setId()` e definir o c√≥digo apropriado.

image::encapsulating-fields.gif[]

Fa√ßa o mesmo para a classe `Cidade`, definindo os atributos abaixo:

[source, java]
----
    private long id;
    private String nome;
    private String uf;
----

=== Utilizando a JPA para acesso ao Banco de Dados

Como falado, a JPA √© uma especifica√ß√£o Java que prov√™ uma forma padr√£o para a implementa√ß√£o de frameworks de ORM como o Hibernate. Assim, se usarmos JPA, podemos trocar o framework por qualquer outro que implementa tal especifica√ß√£o, sem precisarmos alterar nosso c√≥digo fonte (apenas configura√ß√µes ser√£o necess√°rias).

Para usarmos a JPA, e posteriormente o Hibernate em segundo plano, para fazer toda a comunica√ß√£o com o BD, precisamos indicar quais classes representam tabelas no BD. Nossas classes de neg√≥cio `Usuario` e `Cidade` ser√£o as √∫nicas a serem mapeadas para tabelas no banco (por isso chama-se mapeamento objeto-relacional, pois mapeia-se objetos para um BD relacional como o MySQL).

Para indicarmos que uma classe ser√° mapeada, precisamos marc√°-la com a anota√ß√£o `@Entity` da JPA, definindo a classe como uma entidade (uma tabela no BD). Tal anota√ß√£o precisa ser colocada imediatamente antes da declara√ß√£o da classe. Ap√≥s inclu√≠-la, precisaremos importar tal anota√ß√£o. Novamente podemos usar o NetBeans para isso, clicando na l√¢mpada que aparece no lado esquerdo da linha, como mostrado abaixo.

image::define-entity.gif[]

Observe que ap√≥s salvarmos, √© apresentado um erro na linha da declara√ß√£o da classe. Passando o mouse no erro destacado em vermelho, podemos ver que est√° sendo indicado que n√£o h√° nenhum atributo `ID` para a entidade. Podemos clicar na l√¢mpada e usar o NetBeans para definir um `ID`, como mostra a anima√ß√£o acima. 

J√° temos um atributo que chamamos de `id` e que representa a identifica√ß√£o √∫nica de cada objeto da classe (ou seja, a PK na tabela do BD). Assim, apenas indicamos que queremos usar um campo existente como `ID` e ent√£o selecionamos o campo chamado `id`. Com isto, uma anota√ß√£o `@Id` √© colocada no campo.

Para indicarmos que desejamos que o valor deste campo seja gerado automaticamente no BD (para que ele seja definido como autoincrement no MySQL), vamos adicionar a anota√ß√£o `@GeneretedValue`, indicando que a estat√©gia para gera√ß√£o do valor do campo ser√° `IDENTITY`. O atributo `id` deve ficar como abaixo. 

[source, java]
----
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;
----

As classes anotadas com `@Entity` (que a partir de agora, por simplifica√ß√£o chamaremos apenas de Entity) devem implementar a interface `Serializable`, indicando que objetos de tais classes podem ser persistidos (salvos). Tamb√©m podemos usar o NetBeans para fazer essa modifica√ß√£o para n√≥s.

image::implement-serializable.gif[]

O mesmo processo de definir uma entidade, um `ID` e implementar `Serializable` deve ser aplicado para todas as classes de neg√≥cio.

=== Definindo uma Persistence Unit (PU)

Projetos utilizando JPA precisam conter uma Persistence Unit (PU), que √© uma arquivo chamado `persistence.xml` definindo as configura√ß√µes para acesso ao BD, controle de transa√ß√µes, provedor de persist√™ncia a ser utilizado e outras configura√ß√µes. Ele √© o arquivo de configura√ß√£o da JPA.

Uma vez que j√° temos algumas Entities no nosso projeto, podemos facilmente adicionar uma PU utilizando o NetBeans,
como mostra este link:https://youtu.be/7y\--ODvjdjQ[v√≠deo].

video::7y--ODvjdjQ[youtube, 800, 600]

No v√≠deo acima, definimos o nome da PU como `default` (um nome mais simples que o sugerido pelo NetBeans). Como teremos apenas uma PU no nosso projeto (para acessar um √∫nico BD), n√£o precisaremos nos preocupar com este nome. Escolhemos o Persistence Provider como Hibernate (JPA 2.1), indicando que o Hibernate ser√° a implementa√ß√£o da JPA que utilizaremos. No campo Data Source devemos escolher ou configurar uma conex√£o com o BD. Um Data Source (DS) √© uma f√°brica de conex√µes com o BD. 

Temos ent√£o que criar primeiro um DS. Chamamos tal DataSource de "cadastro-rest-ds" e selecionamos a conex√£o com o BD (configurada quando criamos o banco "cadastro-rest"). O nome do DS √© utilizado na PU para poder instanciar uma conex√£o com o banco. Ap√≥s abrir o arquivo `persistence.xml` (que representa as configura√ß√µes da PU), o NetBeans mostra um editor gr√°fico para tal arquivo.

image::persistence-unit.png[]

Alguns pontos importantes s√£o:

- *Persistence Provider*: definimos que desejamos usar Hibernate (como dito antes), como implementa√ß√£o da JPA. 
- *Use Java Transaction APIs*: esta op√ß√£o indica que nossa aplica√ß√£o usar√° a JTA. Esta √© uma API implementada por servidores de aplica√ß√£o como o GlassFish, para prover controle autom√°tico de transa√ß√µes para nossa aplica√ß√£o. Isto quer dizer que n√£o teremos que nos preocupar em abrir, cancelar ou confirmar transa√ß√µes no BD. Tudo isso ser√° feito automaticamente pelo GlassFish.
- *Table Generation Strategy*: est√° como "Create" para permitir que, ao rodar a aplica√ß√£o, as tabelas sejam criadas no BD automaticamente. Depois que elas tiverem sido criadas, podemos alterar para "None". A op√ß√£o "Drop and Create" s√≥ √© interessante se n√£o houver dados que desejamos manter no banco. Assim, sempre que exercutarmos a aplica√ß√£o, as tabelas ser√£o apagadas e recriadas.

H√° apenas alguns detalhes que precisamos observar. Se clicarmos no bot√£o "Source" na parte superior do arquivo, podemos visualizar todo o c√≥digo XML gerado. Quando escolhemos o Hibernate, o valor da tag `<provider>` foi definido como `org.hibernate.ejb.HibernatePersistence`, por√©m, tal provider est√° obsoleto nas vers√µes atuais do Hibernate e deve ser trocado para `org.hibernate.jpa.HibernatePersistenceProvider`.

O provider representa o nome qualificado (incluindo o nome do pacote) da classe que √© capaz de criar objetos `EntityManagerFactory` e a estrutura de tabelas no BD. Um `EntityManagerFactory` √© uma f√°brica de objetos `EntityManager`. Um `EntityManager` (EM), por sua vez, √© respons√°vel por gerenciar o ciclo de vida das entidades como `Usuario` e `Cidade` no nosso sistema. Um EM permite, por exemplo, buscar, incluir, alterar e excluir objetos do BD.     

Por fim, como indicamos que desejamos usar a JTA, da mesma forma que precisamos indicar qual era a classe que implementa o Persistence Provider, precisamos indicar qual a classe que implementa a JTA Platform, respons√°vel por gerenciar as transa√ß√µes no BD.

Como estamos utilizando GlassFish, precisamos adicionar na tag `<properties>` a seguinte propriedade:

[source, xml]
----
<property name="hibernate.transaction.jta.platform" value="org.hibernate.service.jta.platform.internal.SunOneJtaPlatform"/>
----

Esta √© a classe do GlassFish que implementa a JTA Platform.

=== Configurando o CDI

Para permitir o uso de CDI, at√© o JavaEE 6 era obrigat√≥ria a exist√™ncia de um arquivo chamado `beans.xml`. A partir do JavaEE 7 tal arquivo n√£o √© obrigat√≥rio, mas podemos cri√°-lo se quisermos adicionar algumas configura√ß√µes para o CDI.

Pelo menu `File >> New File` do NetBeans, podemos digitar `beans.xml` na janela de pesquisa para criar o arquivo. O arquivo possui um atributo chamado `bean-discovery-mode` que √© definido com valor igual a `annotated`.

Isto indica que s√≥ podemos injetar objetos que estejam marcados com alguma anota√ß√£o que define o escopo dos objetos a serem injetados. Algumas anota√ß√µes de escopo disponibilizadas pelo CDI, que controlam o ciclo de vida de objetos, s√£o o `@ApplicationScoped` e `@RequestScoped`. Um objeto marcado com `@ApplicationScoped` ser√° criado quando requisitado e s√≥ ser√° destru√≠do quando a aplica√ß√£o for finalizada. Um objeto marcado com `@RequestScoped` ser√° criado sempre que for requisitado e ser√° destru√≠do ao final da requisi√ß√£o. Se n√£o marcarmos um objeto com nenhum anota√ß√£o de escopo, seu escopo √© `@Dependent`, que indica que seu ciclo de vida depende do ciclo de vida do objeto onde ele foi criado.

Para n√£o sermos obrigados a anotar todas as classes que desejamos criar objetos por inje√ß√£o e assim tornar mais f√°cil o uso de CDI, podemos alterar o valor do atributo para `all`. Assim, poderemos injetar objetos de qualquer classe que desejarmos.

IMPORTANT: Em aplica√ß√µes com uma grande quantidade de classes, usar `bean-discovery-mode=all` pode causar https://weld.cdi-spec.org/news/2016/10/25/tip3-performance/[maior consumo de mem√≥ria e maior tempo de inicializa√ß√£o].

=== Adicionando depend√™ncias Maven

O arquivo `pom.xml` (criando automaticamente quando criamos o projeto Maven) √© onde indicamos quais s√£o as depend√™ncias do nosso projeto. Como estamos utilizando o Hibernate, precisamos incluir as depend√™ncias a seguir dentro da tag `<dependencies>`:

[source, xml]
----
        <dependency>
            <groupId>org.hibernate.javax.persistence</groupId>
            <artifactId>hibernate-jpa-2.1-api</artifactId>
            <version>1.0.2.Final</version>
        </dependency>
        <dependency>
            <groupId>org.hibernate</groupId>
            <artifactId>hibernate-core</artifactId>
            <version>5.4.12.Final</version>
        </dependency>
        <dependency>
            <groupId>org.hibernate</groupId>
            <artifactId>hibernate-entitymanager</artifactId>
            <version>5.4.12.Final</version>
        </dependency>
----

O uso de CDI n√£o nos dispensa de declarar as depend√™ncias do nosso projeto. O CDI tamb√©m n√£o vai reduzir o n√∫mero de depend√™ncias. Nosso projeto continua dependendo daquilo que ele usa. O que o CDI garante √© que seja f√°cil trocar a implementa√ß√£o de uma depend√™ncia por outra, sem precisar alterar o c√≥digo, mas somente as configura√ß√µes como acima.

Nosso projeto depende de uma implementa√ß√£o da JPA. Usaremos CDI para injetar objetos que implementam a especifica√ß√£o JPA. Neste caso, tais objetos s√£o de classes implementadas pelo Hibernate, que √© o chamado Persistence Provider. Se decidirmos trocar o Hibernate por outra implementa√ß√£o (como o EclipseLink), trocamos apenas as depend√™ncias e configura√ß√µes no `persistence.xml` e o CDI se encarregar√° de injetar os objetos criados pelo provider (como o `EntityManager` discutido anteriormente).

=== Instanciando um EntityManager para manipular dados no BD

A classe `EntityManager`, como dito anteriormente, controla o ciclo de vida de Entities (classes de neg√≥cio anotadas com `@Entity`) e permite persistir tais objetos no BD. Para instanciar um `EntityManager` precisar√≠amos de um objeto `EntityManagerFactory` que √© uma f√°brica de `EntityManagers`. No entanto, usando CDI, podemos injetar `EntityManagers` automaticamente, sempre que seu uso for necess√°rio, sem precisarmos recorrer a um `EntityManagerFactory`. 

Podemos injetar `EntityMangers` em classes que tenham o ciclo de vida controlado pelo servidor de aplica√ß√£o. Para isso, precisar√≠amos declarar um objeto `EntityManager` e anot√°-lo com `@PersistenceContext`. Por√©m, ter√≠amos que utilizar esta anota√ß√£o em todos os locais onde declarassemos tal objeto. Para n√£o termos que fazer isso e centralizarmos o processo de inje√ß√£o de qualquer `EntityManager` em um s√≥ lugar, vamos criar uma classe `Producers` dentro do pacote `com.manoelcampos.server.config`. A classe e o pacote podem ter qualquer nome que desejar. Esta classe representa um produtor (f√°brica) de objetos e usar√° recursos do CDI para definir como determinados objetos mais complexos, como um `EntityManager`, devem ser criados. A classe deve ter o c√≥digo apresentado a seguir:

[source, java]
----
package com.manoelcampos.server.config;

import javax.enterprise.inject.Produces;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

public class Producers {
    @Produces 
    @PersistenceContext
    private EntityManager em;
}
----

O c√≥digo acima declara um `EntityManager` (EM) e o anota com `@PersistenceContext`. Assim, o EM ser√° gerenciado pelo servidor de aplica√ß√£o (que √© chamado de https://eclipse-ee4j.github.io/jakartaee-tutorial/persistence-intro004.html#BNBQZ[Container-managed EntityManager]) e automaticamente injetado quando requisitado, utilizando as configura√ß√µes definidas no `persistence.xml`. Como temos apenas uma Persistence Unit (PU) dentro de tal arquivo, n√£o precisamos nos preocupar em definir o nome de tal PU ao anotar o `EntityManager`. Mas se quisessemos explicitar o nome da PU (que n√£o √© recomend√°vel, pois este pode ser renomeado no arquivo xml), poder√≠amos alterar a anota√ß√£o para `@PersistenceContext(name = "default")`, onde `default` foi o nome que demos pra nossa PU. Mas isso s√≥ √© aconsolh√°vel se tivermos mais de uma PU no `persistence.xml`.

Observe que o EM tamb√©m est√° anotado com `@Produces`. Isto quer dizer que sempre que precisarmos de um EM, uma inst√¢ncia ser√° criada neste atributo `em` e retornado para o local onde foi solicitado.

=== Implementando o padr√£o DAO

Supondo que estamos desenvolvendo esta aplica√ß√£o para um determinado cliente, nossas classes de neg√≥cio `Usuario` e `Cidade` s√£o classes espec√≠ficas do neg√≥cio do cliente. O EM disponibiliza m√©todos para persistir objetos no BD. Assim, para incluir, alterar ou excluir um objeto no BD, precisamos chamar estes m√©todos do EM. 

Para n√£o incluir tal c√≥digo dentro das classes de neg√≥cio (que devem ter apenas c√≥digo referente ao neg√≥cio do cliente), √© comum a utiliza√ß√£o do padr√£o https://pt.wikipedia.org/wiki/Objeto_de_acesso_a_dados[Data Access Object (DAO)] para permitir a separa√ß√£o de conceitos (https://pt.wikipedia.org/wiki/Separa√ß√£o_de_conceitos[Separation of Concerns, SoC]). A SoC evita misturar c√≥digo de um determinado n√≠vel de abstra√ß√£o com outros de outro n√≠vel. As classes de neg√≥cio como `Usuario` podem ter c√≥digo para validar o CPF, enquanto opera√ß√µes de BD n√£o est√£o relacionadas com o neg√≥cio e assim devem ser mantidas separadas.

Para implementar o padr√£o DAO, precisar√≠amos criar uma classe DAO para cada classe de neg√≥cio. Assim, ter√≠amos uma classe `UsuarioDAO` e `CidadeDAO`. Como um DAO prover√° m√©todos para manipular dados no BD, como `salvar` e `remover`, tais m√©todos acabam ficando duplicados entre os DAOs. Para evitar isso, podemos criar um DAO gen√©rico que funciona para qualquer classe de neg√≥cio. Isto pode ter suas desvantagens, mas n√£o vamos discut√≠-las nesse artigo.

Primeiro, vamos definir uma interface chamada DAO, dentro do pacote `com.manoelcampos.server.dao`.

[source, java]
----
package com.manoelcampos.server.dao;

import com.manoelcampos.server.model.Cadastro;

public interface DAO<T extends Cadastro> {
    T findById(long id);
    T findByField(String fieldName, Object value);
    boolean delete(T entity);
    boolean delete(long id);
    long save(T entity);
}
----

Tal interface define m√©todos para:

- localizar um objeto no BD a partir do seu id: `findById()`;
- localizar por um campo espec√≠fico: `findByField()`;
- remover: `delete(T entity)` e `delete(long id)`;
- e salvar um objeto no BD, retornando o id gerado: `save()`. 

A interface usa https://www.devmedia.com.br/usando-generics-em-java/28981[Generics] para permitir indicar qual o tipo de objeto de neg√≥cio (que implementa a interface `Cadastro`) um DAO trabalhar√°. Assim, quando mandarmos localizar um `Usuario` utilizando seu id, teremos como retorno um objeto `Usuario` e n√£o um objeto gen√©rico como `Object`. Generics √© um assunto bem extenso que est√° fora do escopo deste artigo.

Agora que definimos uma interface padr√£o para nossos DAOs, vamos criar uma classe que utilizar√° JPA para implementar tal interface. Definir a interface e criar uma classe que a implementa √© muito √∫til se desejarmos criar outras formas de persist√™ncia para nossos objetos de neg√≥cio. Por exemplo, poder√≠amos desejar persistir os objetos em um BD usando JPA e tamb√©m em arquivos, utilizando o recurso de serializa√ß√£o do Java. Para isso, poder√≠amos ter classes DAO implementando diferentes mecanismos de persist√™ncia de dados.

Assim, crie a classe `JpaDAO` no pacote `com.manoelcampos.server.dao` como abaixo. Ela usa um `EntityManager` para persistir um objeto de neg√≥cio no BD. O tipo de objeto de neg√≥cio √© definido utilizando Generics, como feito na interface `DAO`.

[source, java]
----
package com.manoelcampos.server.dao;

import com.manoelcampos.server.model.Cadastro;
import javax.persistence.EntityManager;
import javax.persistence.Query;
import javax.persistence.TypedQuery;

public class JpaDAO<T extends Cadastro> implements DAO<T> {
    private final EntityManager em;
    private final Class<T> classe;
    
    public JpaDAO(EntityManager em, Class<T> classe){
        this.em = em;
        this.classe = classe;
    }

    @Override
    public T findById(long id) {
        return em.find(classe, id);
    }

    @Override
    public boolean delete(T entity) {
        em.remove(entity);
        return true;
    }

    @Override
    public boolean delete(long id) {
        T entity = findById(id);
        return delete(entity);
    }

    @Override
    public long save(T entity) {
        if(entity.getId() > 0)
            em.merge(entity);
        else em.persist(entity);
        
        return entity.getId();
    }

    @Override
    public T findByField(String fieldName, Object value) {
        final String jpql = "select o from " + classe.getSimpleName() + " o " +
                            " where o." + fieldName + " = :" + fieldName;
        TypedQuery<T> query = em.createQuery(jpql, classe);
        query.setParameter(fieldName, value);
        return query.getSingleResult();
    }
}
----

Como pode ser observado acima, os m√©todos para fazer a manipula√ß√£o dos dados no BD s√£o extremamente simples. 
Alguns m√©todos merecem maiores esclarecimentos:

- o m√©todo `save()` pode tanto inserir ou alterar um objeto no BD. Assim, precisamos saber qual dessas duas opera√ß√µes deve ser realizada. Uma forma simpl√≥ria (para n√£o complicar as coisas aqui) de fazer isso √© verificar se o objeto (par√¢metro `entity`) possui um valor pro atributo `id`, ou seja, se tal atributo tem valor maior que zero. 
Neste caso, isto indica que o objeto j√° existe no BD e precisamos fazer um update chamando o m√©todo `em.merge(entity)`. Caso contr√°rio, chamamos o `em.persist(entity)` pra incluir o objeto no BD.
- o m√©todo `delete()` possui duas vers√µes: uma que recebe a entidade (objeto) a ser exclu√≠do e outra que recebe apenas o id do objeto. Na JPA, para excluir um objeto do banco, precisamos ter uma inst√¢ncia de tal objeto. Usando o m√©todo que recebe apenas o id, teremos que primeiro localizar o objeto no banco e ent√£o excluir tal objeto. Como no servi√ßo REST o mais f√°cil √© passarmos apenas o id do objeto a ser exclu√≠do, √© mais simples usar a vers√£o do m√©todo que recebe apenas o id.

J√° a instancia√ß√£o de um `JpaDAO` n√£o √© t√£o simples assim. Para criar tal objeto √© preciso passar dois par√¢metros para o construtor. Sempre que precisarmos instanciar um `JpaDAO`, precisaremos passar estes par√¢metros. √â nesses casos em que a inje√ß√£o de depend√™ncias tem mais valor.

Quando usamos inje√ß√£o de depend√™ncia com CDI, objetos podem ser criados automaticamente, desde que eles tenham um construtor padr√£o. Como a classe `JpaDAO` (que √© a √∫nica implementa√ß√£o da interface `DAO`) n√£o possui um construtor padr√£o, n√£o podemos injetar objetos `DAO` diretamente. Precisamos criar um c√≥digo adicional para indicar ao CDI como objetos `DAO` devem ser criados, at√© porque se tivessemos mais de uma implementa√ß√£o da interface `DAO`, o CDI n√£o saberia qual classe concreta instanciar para injetar um objeto que implementa tal interface.

A grande vantagem √© que, apesar de termos um trabalho adicional para informar ao CDI como criar DAOs, teremos que fazer isso em um √∫nico lugar, ao inv√©s de ter que passar esses par√¢metros para criar um DAO em todo lugar que declararmos um. Para fazer isso, vamos alterar a classe `Producers` como abaixo:

[source, java]
----
package com.manoelcampos.server.config;

import com.manoelcampos.server.dao.DAO;
import com.manoelcampos.server.dao.JpaDAO;
import com.manoelcampos.server.model.Cadastro;
import java.lang.reflect.ParameterizedType;
import javax.enterprise.inject.Produces;
import javax.enterprise.inject.spi.InjectionPoint;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

public class Producers {
    @Produces 
    @PersistenceContext
    private EntityManager em;
    
    @Produces
    public <T extends Cadastro> DAO<T> getDao(InjectionPoint ip){
        ParameterizedType t = (ParameterizedType) ip.getType();
        Class classe = (Class) t.getActualTypeArguments()[0];
        return new JpaDAO(em, classe);
    }        
}
----

Neste caso, definimos um m√©todo anotado com `@Produces`. Isto √© necess√°rio pois o CDI n√£o sabe como instanciar um `DAO`, uma vez que esta √© uma classe que n√≥s criamos. Por mais que um `EntityManager` seja ainda mais complexo de ser criado, o CDI j√° tem recursos para instanciar tais objetos pra n√≥s.
O m√©todo `getDao` ent√£o ser√° chamado automaticamente, toda vez que um objeto `DAO` anotado com `@Inject` precisar ser criado. Lembre que o `@Inject` indica que um objeto deve ser injetado al√≠.

O par√¢metro `ip` que tal m√©todo recebe, conter√° informa√ß√µes sobre o local onde foi solicitada a inje√ß√£o do `DAO`. Para declarar um `DAO` (por exemplo, para manipular objetos `Usuario`) temos que escrever `@Inject DAO<Usuario> dao`. A classe entre < e > indica quais objetos de neg√≥cio o `DAO` manipular√°. Este par√¢metro `ip` conter√° informa√ß√µes como qual tipo gen√©rico (definido entre < e >) est√° associado ao `DAO`. Com isto, conseguimos obter a classe entre < e > e assim criar um `DAO` instanciando um objeto `JpaDAO` para manipular objetos de tal classe. Como tal objeto tamb√©m requer um `EntityManager`, podemos simplesmente acessar o atributo `em` declarado dentro da pr√≥pria classe `Producers`. Quando fizermos isso, um `EntityManager` ser√° produzido e passado para o `JpaDAO` criado.

=== Configurando o Servidor REST

Para criarmos e executarmos nossos servi√ßos REST, precisamos habilitar o uso de REST no projeto. Para isto, basta criar uma classe como `RestConfig` no pacote `com.manoelcampos.server.config` (o nome da classe e do pacote podem ser qualquer um). Tal classe deve extender `javax.ws.rs.core.Application` e deve ser anotada com `@javax.ws.rs.ApplicationPath("api")`, onde `api` pode ser qualquer nome que indica a raiz a partir da qual os sevi√ßos REST estar√£o dispon√≠veis. Tal classe n√£o precisa ter m√©todos, construtor nem atributo algum, como mostrado abaixo.

[source, java]
----
package com.manoelcampos.server.config;

import javax.ws.rs.core.Application;

@javax.ws.rs.ApplicationPath("api")
public class RestConfig extends Application {

}
----

Uma vez que estamos rodando o GlassFish localmente e que nosso projeto chama `server`, a URL para acessar a aplica√ß√£o seria http://localhost:8080/server/. 

Ao executar o projeto, uma p√°gina como http://localhost:8080/server/ ser√° acessada. A API REST estar√° dispon√≠vel a partir de outro diret√≥rio, como especificado na anota√ß√£o `@javax.ws.rs.ApplicationPath`. Neste caso, a URL base para acesso aos recursos ser√° http://localhost:8080/server/api. Mas n√£o adianta tentar acessar tal URL, pois ela por si s√≥ n√£o funciona: precisamos implementar nosso primeiro servi√ßo que vai ser acessar a partir de um caminho adicional depois de tal URL.

=== Implementando o Servidor REST

O servi√ßo REST que vamos implementar vai fornecer as famosas opera√ß√µes CRUD (Create, Read, Update e Delete)
que permite inserir (Criar), obter (Ler), alterar (Atualizar) e deletar registros de uma tabela de um BD.
Como pode ser visto link:../introducao-webservices.pptx[nesta apresenta√ß√£o], em servi√ßos REST, tais m√©todos CRUD devem ser associados a determinados m√©todos HTTP. A tabela abaixo a associa√ß√£o entre verbos HTTP, opera√ß√µes CRUD e comandos SQL.

|===
|*Verbo (M√©todo) HTTP* |*Opera√ß√£o CRUD* |*Comando SQL*
|POST                  |**C**reate      | insert
|GET                   |**R**ead        | select
|PUT                   |**U**pdate      | update
|DELETE                |**D**elete      | delete
|===

Assim, para cada m√©todo a ser implementado na classe do servi√ßo em Java, precisamos indicar qual o verbo HTTP que deve ser usado para acessar o m√©todo remotamente.

==== Criando a classe do primeiro servi√ßo REST

Toda a infraestrutura da nossa aplica√ß√£o est√° pronta. Agora, vamos criar nosso Web Service (WS) REST. Tal WS disponibilizar√° opera√ß√µes para manipular usu√°rios no BD, assim como as opera√ß√µes definidas no `DAO`. Web Services REST s√£o acessados normalmente por meio de URLs amig√°veis. Cada URL permite realizar opera√ß√µes sobre um determindao recurso, por meio de requisi√ß√µes utilizando os verbos do protocolo HTTP. Cada uma destas URLs √© chamada de _endpoints_, que no c√≥digo Java representam m√©todos a serem acessados remotamente por meio de requisi√ß√µes HTTP. 

Na terminologia REST, um recurso pode ser um arquivo qualquer, uma imagem, dados obtidos de uma tabela em um BD (como √© o nosso caso), etc. Assim, para podermos disponibilizar as opera√ß√µes do `DAO` para objetos `Usuario`, precisamos criar uma classe `UsuarioResource` no pacote `com.manoelcampos.server.rest`, como abaixo.

[source, java]
----
package com.manoelcampos.server.rest;

import com.manoelcampos.server.dao.DAO;
import com.manoelcampos.server.model.Usuario;
import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

@Path("/usuario")
public class UsuarioResource {
    @Inject 
    private DAO<Usuario> dao;
    
    @GET
    @Path("{id}")
    @Produces(MediaType.APPLICATION_JSON)
    public Usuario findById(@PathParam("id") long id) {
        return dao.findById(id);
    }
}
----

Para publicar tal classe como um recurso acess√≠vel via HTTP, precisamos incluir a anota√ß√£o `@Path` antes da declara√ß√£o da classe e indicar o caminho que ser√° utilizado para acessar tal recurso por meio de uma URL. Neste caso, indicamos que um recurso `Usuario` poder√° ser acessado a partir do caminho `/usuario`. O acesso ao recurso s√≥ acontece quando um determinado m√©todo da classe √© executado. Cada m√©todo ent√£o define um caminho adicional a partir de `/usuario` que permitir√° que o m√©todo seja chamado por uma requisi√ß√£o HTTP. No caso do m√©todo `findById` (que possui o mesmo nome que no `DAO`), ele ser√° acessado a partir de `/usuario/{id}`, onde `{id}` representa o id do usu√°rio que deseja-se obter. 

[IMPORTANT]
====
A URL para acesso a um determinado m√©todo √© formada pela:

- URL base da aplica√ß√£o, normalmente http&#58;//localhost:8080/NomeDaAplicacao
- caminho (`@Path`) base do servi√ßo REST, definido na classe `RestConfig` como `api`
- caminho da classe do servi√ßo
- caminho do m√©todo a ser acessado (incluindo poss√≠veis par√¢metros).

Assim, a URL completa para acesso ao m√©todo `findById()` da classe `UsuarioResource` seria algo como:

- http&#58;//localhost:8080/server
- /api
- /usuario
- /{id}

ou seja: http://localhost:8080/server/api/usuario/{id}, onde {id} deve ser substitu√≠do pelo id do usu√°rio que deseja-se obter.
====

Observe que o m√©todo `findById` possui um par√¢metro id. Quando utilizamos a anota√ß√£o `@Path` para indicar qual o caminho a ser utilizado para acessar tal m√©todo via HTTP, definimos o nome como `{id}` (entre chaves), para indicar que `id` deve ser um valor a ser passado na URL ap√≥s `/usuario`. Esta valor ser√° passado automaticamente para o par√¢metro id do m√©todo, uma vez que utilizamos a tag `@PathParam` para indicar isso. Note que no `@PathParam` n√£o se usa chaves. Assim, se acessarmos uma URL terminada em `/usuario/1`, estamos querendo obter o usu√°rio de id igual a 1. Assim, o valor para o par√¢metro `id` √© obtido a partir da URL e passado para o par√¢metro id no m√©todo.

IMPORTANT: Certifique-se de incluir a anota√ß√£o `@PathParam` correta, do pacote `javax.ws.rs`. Como existe uma anota√ß√£o de mesmo nome no pacote `javax.websocket.server`, incluir esta vai causar o erro _"The request entity cannot be empty"_. Tal erro indica que o par√¢metro anotado com a `@PathParam` incorreta n√£o recebeu o valor passado pela URL (como especificado na anota√ß√£o `@Path` do m√©todo `findById()`).

Este m√©todo est√° anotado com `@Produces`, para indicar que o retorno do m√©todo deve ser convertido para JSON.
Esta anota√ß√£o n√£o √© a mesma `@Produces` vista anteriormente para o CDI. Apesar de ter o mesmo nome, a finalidade √© outra.
A anota√ß√£o `@Produces` do JAX-RS √© usada para indicar que formato deve ser usado para converter os dados retornados por um m√©todo. Como o mais usual em servi√ßos REST √© o formato JSON, usamos tal anota√ß√£o para que o JAX-RS fa√ßa a convers√£o do objeto usu√°rio retornado pelo m√©todo `findById()` para JSON.
Assim, tenha certeza de importar a anota√ß√£o `@Produces` do pacote `javax.ws.rs.Produces` e n√£o a anota√ß√£o do CDI.

Por fim, tamb√©m anotamos o m√©todo `findById()` com `@GET` para indicar que este m√©todo s√≥ aceita requisi√ß√µes HTTP com o verbo GET. Se utilizarmos um verbo que o m√©todo n√£o aceita, receberemos o erro _"405 Method Not Allowed_", ou seja "Erro HTTP 405: M√©todo (Verbo) n√£o Permitido".

==== Implementando m√©todo para inserir usu√°rio

Definimos que o m√©todo `findById()` ser√° acessado remotamente por meio do verbo GET do HTTP. Assim, estamos implementando a opera√ß√£o Read do CRUD. Como j√° temos o DAO implementando as opera√ß√µes CRUD, √© bastante simples disponibilizar tais opera√ß√µes no nosso servi√ßo REST. Vamos come√ßar adicionando o m√©todo insert na classe `UsuarioResource`.

[source, java]
----
@POST
@Consumes(MediaType.APPLICATION_JSON)
public long insert(Usuario usuario) {
    return dao.save(usuario);
}
----

De acordo com a tabela mostrada anteriormente, para inserir um registro no banco (opera√ß√£o Create do CRUD), devemos usar o verbo POST do HTTP, anotando o m√©todo `insert()` com `@POST`. Neste caso, n√£o inclu√≠mos uma anota√ß√£o `@Path` pois n√£o queremos que seja utilizado um caminho adicional, al√©m do j√° existente `/usuario`, para inserir um usu√°rio no banco. Se acessarmos tal URL por meio do verbo POST, o servidor REST entender√° que queremos chamar o m√©todo `insert()` mostrado acima.
Neste caso, como vamos passar um usu√°rio a ser inserido no banco, o par√¢metro do `insert()` √© um objeto da classe `Usuario` e n√£o um id num√©rico. 

IMPORTANT: Tenha certeza de importar a anota√ß√£o `@POST` correta, do pacote `javax.ws.rs`. Importando outra anota√ß√£o que possa aparecer nas op√ß√µes do IDE ir√° fazer com que o projeto n√£o compile.

No caso de requisi√ß√µes POST, os dados passados n√£o v√£o na URL (como no verbo GET). Assim, n√£o usamos a anota√ß√£o `@PathParam` no par√¢metro do m√©todo e nem inclu√≠mos par√¢metro algum na anota√ß√£o `@Path`. At√© porque, neste exemplo n√£o quisemos definir um caminho adicional para acessar o m√©todo, logo, n√£o precisamos da `@Path`.

Observe que anotamos o m√©todo `insert()` com `@Consumes` e n√£o `@Produces`, pois este m√©todo consome (recebe) dados em formato JSON, no lugar de produzir (retornar) dados em JSON. Como o m√©todo est√° retornando um tipo primitivo (o id do usu√°rio inserido), n√£o precisamos converter o retorno para JSON. Assim, o m√©todo apenas consome JSON.

[TIP]
====
Uma dica f√°cil para saber qual anota√ß√£o usar √©: 

- quando o m√©todo recebe um objeto, ele vai consumir (`@Consumes`);
- quando retorna um objeto ele vai produzir (`@Produces`).
====

=== Executando a aplica√ß√£o

Antes de acessar uma URL de um m√©todo de um servi√ßo REST implementado, precisamos clicar no bot√£o `Build` para compilar todo o projeto. Sempre que salvamos o projeto, as classes alteradas s√£o compiladas e o projeto √© reimplantado (_redeployed_) automaticamente. Normalmente, como fizemos in√∫meras altera√ß√µes no projeto e nunca executamos o mesmo, √© aconselh√°vel clicar no bot√£o `Clean and Build` (Limpar e Construir) para apagar quaisquer vers√µes anteriores das classes compiladas e implantar as novas. Muitos erros ocorrem quando fazemos altera√ß√µes estruturais no projeto (como mudar nome de classes e m√©todos, remover m√©todos, mudar par√¢metros, etc) e n√£o usamos tal bot√£o. Agora, podemos clicar no bot√£o `Play` (F6) para executar o projeto. Sem isso, o WS REST n√£o poder√° ser acessadso.

Ao executar o projeto, uma p√°gina como http://localhost:8080/server/ ser√° exibida, apenas pelo fato de um arquivo index.html ser criado automaticamente quando criamos o projeto. Ent√£o, esta p√°gina de fato n√£o exibir√° nada. A API REST estar√° dispon√≠vel a partir de um caminho adicional. J√° sabemos que a URL base dos servi√ßos REST ser√° http://localhost:8080/server/api/PathDeUmRecurso/PathDeUmMetodo. 

Ent√£o, para acessar o m√©todo `findById` do recurso `Usuario`, a URL completa seria algo como http://localhost:8080/server/api/usuario/1.

Se uma classe como a `RestConfig` (mostrada no in√≠cio da se√ß√£o) n√£o foi criada, o NetBeans dar√° um aviso na linha da declara√ß√£o de qualquer classe anotada com `@Path` e permitir√° adicionar a classe de configura√ß√£o automaticamente. Esta √© uma forma simples de n√£o precisarmos ter que lembrar como deve ser esta classe `RestConfig`. Apenas lembre que a classe n√£o precisa ter m√©todo algum. 

Usando este assistente do NetBeans, ele adicionar√° c√≥digo dentro de tal classe que de fato n√£o funcionar√° (pelo menos n√£o para as vers√µes de bibliotecas e ferramentas utilizadas). Assim, se usar tal assistente para criar a classe, apague qualquer m√©todo e atributo adicionado. Lembre tamb√©m de definir o nome pelo qual deseja acessar os recursos por meio de REST, dentro da anota√ß√£o `@ApplicationPath()`. No nosso caso definimos o caminho como _"api"_. 

== Testando o servi√ßo criado

Para testar o servi√ßo REST, podemos desenvolver uma aplica√ß√£o cliente em qualquer linguagem que desejarmos,
para qualquer plataforma (web, mobile, desktop). O projeto link:client[cliente] √© um exemplo de uma aplica√ß√£o
de linha de comando em Java que consome tal servi√ßo.

Testar um m√©todo REST que usa o verbo HTTP GET √© trivial: basta digitar a URL do m√©todo, passando os devidos par√¢metros.
No entanto, quando um m√©todo usa outro verbo HTTP, n√£o conseguimos testar desta forma.
Se voc√™ n√£o quiser criar uma aplica√ß√£o cliente apenas para testar o servi√ßo, existem v√°rias alternativas para isto.
A forma mais simples, que n√£o requer instala√ß√£o de nenhuma ferramenta adicional, √© usando o 
site https://postwoman.io

=== Usando a ferramenta de linha de comando curl

O curl √© uma ferramenta que j√° vem instalada na maioria das distribui√ß√µes Linux.
Abaixo mostro como usar o comando curl no terminal para enviar uma requisi√ß√£o HTTP para diferentes m√©todos
publicados por um servi√ßo REST (como o servi√ßo de usu√°rios desenvolvido aqui). 

|===
|*M√©todo* |*Verbo HTTP* |*Comando curl completo*
|Inserir Usu√°rio  |POST |curl -X POST -d '{"cpf": "99999999999", "nome": "Jo√£o"}' -H "Content-Type: application/json" http://localhost:8080/server/api/usuario/
|Buscar Usu√°rio  |GET |curl http://localhost:8080/server/api/usuario/1
|Alterar Usu√°rio  |PUT |curl -X PUT -d '{"id": 1, "cpf": "11111111111", "nome": "Maria"}' -H "Content-Type: application/json" http://localhost:8080/server/api/usuario/
|Excluir Usu√°rio  |DELETE |curl -X DELETE http://localhost:8080/server/api/usuario/1
|===

WARNING: Observe que ainda n√£o implementamos os m√©todos para alterar e excluir usu√°rios (verbos POST e PUT). *No caso da opera√ß√£o de inserir usu√°rios, se tentar acess√°-la, ver√° que ocorrer√° um erro. Isto ser√° explicado na pr√≥xima se√ß√£o.*

Para opera√ß√µes POST e PUT, √© comum passarmos no corpo da mensagem HTTP o conte√∫do a ser enviado na requisi√ß√£o.
Nos exemplos acima, √© passado um objeto `Usuario` em formato JSON. Neste caso, precisamos incluir o cabe√ßalho
`Content-Type` para indicar que estamos enviando um conte√∫do em JSON na requisi√ß√£o HTTP.

IMPORTANT: Observe que ao enviar conte√∫do JSON, √© preciso usar aspas duplas ao redor do nome de atributos e valores. Todo o c√≥digo JSON deve ser envolvido em aspas simples, n√£o o contr√°rio. Se as aspas forem invertidas, o servidor indicar√° que o JSON √© inv√°lido. 

=== Usando extens√µes para navegadores Web

Voc√™ tamb√©m pode utilizar o pr√≥prio navegador para testar seus servi√ßos REST. Assim, voc√™ ter√° uma interface web amig√°vel e intuitiva, facilitando muito os testes. A seguir s√£o exibidas op√ß√µes para Firefox e Chrome.

- Para o Firefox voc√™ pode baixar o plugin https://addons.mozilla.org/pt-BR/firefox/addon/restclient/[RESTClient].
- Para o Google Chrome utilizo a excelente extens√£o https://chrome.google.com/webstore/detail/restlet-client-rest-api-t/aejoelaoggembcahagimdiliamlcdmfm/[Talend API Tester (antigo Restlet Client)]. 

A extens√£o _Talend API Tester_ tem um recurso extremamente √∫til de permitir criar projetos e salvar diferentes requisi√ß√µes HTTP
dentro deste projeto. Assim, podemos facilmente reenviar tais requisi√ß√µes sem ter que configur√°-las novamente.
Muitas vezes, apenas alteramos valores de par√¢metros e pronto. A imagem abaixo apresenta um exemplo de um projeto
criado em tal ferramenta.

image:restlet-client-chrome.png[]

Todos os dados usadas nos exemplos de envio de requisi√ß√£o utilizando o comando curl na se√ß√£o anterior devem
ser utilizados para preencher os campos na tela da extens√£o que voc√™ estiver usando no seu navegador, incluindo:

- o verbo HTTP;
- o conte√∫do do corpo da mensagem (como nos casos de POST e PUT)
e cabe√ßalho para indicar o formato de tal conte√∫do (no nosso caso, JSON).

=== Testando o m√©todo de incluir usu√°rio

Se voc√™ tentar acessar o m√©todo `insert()` da classe `UsuarioResource` para incluir um usu√°rio, ver√° que ocorre a exce√ß√£o _javax.persistence.TransactionRequiredException_, provavelmente sem apresentar nenhuma mensagem de erro. Tal exce√ß√£o indica que tentamos executar uma opera√ß√£o que exigia uma transa√ß√£o, mas esta n√£o foi aberta. Neste caso, estamos falando de transa√ß√µes de banco de dados. Como estamos usando JPA, para fazer alguma opera√ß√£o que altera dados no banco, precisamos: 

1. iniciar uma transa√ß√£o; 
2. executar a(s) opera√ß√£o(√µes); 
3. se a(s) opera√ß√£o(√µes) foi(foram) executada(s) com sucesso, devemos fazer um _commit_ na transa√ß√£o para efetivamente confirmar as altera√ß√µes no banco;
4. se ocorrer algum erro ocorreu, devemos fazer um _rollback_ para desfazer qualquer opera√ß√£o que tenha sido feita depois que a transa√ß√£o foi iniciada.

Lembra que l√° no in√≠cio configuramos a tal da JTA (Java Transaction API)? Pois √©, esta API permite que o servidor de aplica√ß√£o (GlassFish no nosso caso) controle este ciclo de vida de transa√ß√µes apresentado acima. Assim, n√£o temos que escrever c√≥digo para definir tais passos. Com a JTA, podemos apenas usar uma simples anota√ß√£o para indicar que queremos usar transa√ß√µes de banco de dados nas nossas classes de servi√ßos REST e tudo funcionar√° automaticamente, feito m√°gica. Costumamos dizer que este tipo de recurso √© *autom√°gico* ü§£.

Ent√£o, para os m√©todos de inser√ß√£o, altera√ß√£o e exclus√£o funcionarem, podemos anotar a classe `UsuarioResource` com `@Transactional`.

=== Implementando m√©todo para alterar e excluir usu√°rio

Por fim, vamos adicionar o c√≥digo na classe `UsuarioResource` para os m√©todos de altera√ß√£o e exclus√£o de usu√°rios, como mostrado a seguir.
O c√≥digo dispensa coment√°rios, pois todos os detalhes j√° foram explicados na implementa√ß√£o dos m√©todos anteriores.

[source, java]
----
@PUT
@Consumes(MediaType.APPLICATION_JSON)
public boolean update(Usuario usuario) {
    //Se retornou um id maior que 0, √© porque o usu√°rio foi salvo no BD
    return dao.save(usuario) > 0;
}

@DELETE
@Path("{id}")
public boolean delete(@PathParam("id") long id) {
    return dao.delete(id);
}
----

Pronto, agora pode usar alguma das formas mostradas anteriormente para testar qualquer m√©todo do servi√ßo REST implementado.
Espero que o tutorial tenha sido completo e esclarecedor.
Se encontrar algum erro, algo que ficou mal explicado ou que pode ser melhorado, basta criar uma nova issue https://github.com/manoelcampos/sd-webservices/issues[aqui].

== Download do c√≥digo fonte

O c√≥digo fonte do projeto pode ser baixado como zip link:https://kinolien.github.io/gitzip/?download=/manoelcampos/sd-webservices/tree/master/4.4-ws-rest-cadastro[aqui].
